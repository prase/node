import { ASTNode } from 'parse5';
import { Analyzer } from 'polymer-analyzer';
import { Document } from 'polymer-analyzer/lib/model/document';
import { BundleStrategy, AssignedBundle, BundleUrlMapper, BundleManifest } from './bundle-manifest';
import { DocumentCollection } from './document-collection';
export interface Options {
    basePath?: string;
    addedImports?: string[];
    analyzer?: Analyzer;
    excludes?: string[];
    noImplicitStrip?: boolean;
    inlineCss?: boolean;
    inlineScripts?: boolean;
    inputUrl?: string;
    stripComments?: boolean;
    stripExcludes?: string[];
}
export declare class Bundler {
    basePath?: string;
    addedImports: string[];
    analyzer: Analyzer;
    enableCssInlining: boolean;
    enableScriptInlining: boolean;
    excludes: string[];
    implicitStrip: boolean;
    inputUrl: string;
    stripComments: boolean;
    stripExcludes: string[];
    constructor(options?: Options);
    /**
     * Return the URL this import should point to in the given bundle.
     *
     * If the URL is part of the bundle, this method returns `true`.
     *
     * If the URL is part of another bundle, this method returns the url of that
     * bundle.
     *
     * If the URL isn't part of a bundle, this method returns `false`
     */
    resolveBundleUrl(url: string, bundle: AssignedBundle, manifest: BundleManifest): boolean | string;
    isStripExcludedHref(url: string): boolean;
    isBlankTextNode(node: ASTNode): boolean;
    removeElementAndNewline(node: ASTNode, replacement?: ASTNode): void;
    isLicenseComment(node: ASTNode): boolean;
    /**
     * Creates a hidden container <div> to which inlined content will be
     * appended.
     */
    createHiddenContainerNode(): ASTNode;
    /**
     * Inline external scripts <script src="*">
     */
    inlineScript(docUrl: string, externalScript: ASTNode): Promise<ASTNode | undefined>;
    /**
     * Inline a stylesheet (either from deprecated polymer-style css import `<link
     * rel="import" type="css">` import or regular external stylesheet link
     * `<link rel="stylesheet">`.
     */
    inlineStylesheet(docUrl: string, cssLink: ASTNode): Promise<ASTNode | undefined>;
    /**
     * Inline external HTML files <link type="import" href="*">
     * TODO(usergenic): Refactor method to simplify and encapsulate case handling
     *     for hidden div adjacency etc.
     */
    inlineHtmlImport(docUrl: string, htmlImport: ASTNode, reachedImports: Set<string>, bundle: AssignedBundle, manifest: BundleManifest): Promise<void>;
    oldPolymerCheck(analyzedRoot: Document): void;
    rewriteImportedStyleTextUrls(importUrl: string, mainDocUrl: string, cssText: string): string;
    rewriteImportedUrls(importDoc: ASTNode, importUrl: string, mainDocUrl: string): void;
    /**
     * Old Polymer supported `<style>` tag in `<dom-module>` but outside of
     * `<template>`.  This is also where the deprecated Polymer CSS import tag
     * `<link rel="import" type="css">` would generate inline `<style>`.
     * Migrates these `<style>` tags into available `<template>` of the
     * `<dom-module>`.  Will create a `<template>` container if not present.
     */
    moveDomModuleStyleIntoTemplate(style: ASTNode): void;
    /**
     * Given a URL to an entry-point html document, produce a single document
     * with HTML imports, external stylesheets and external scripts inlined,
     * according to the options for this Bundler.
     *
     * TODO: Given Multiple urls, produces a sharded build by applying the
     * provided
     * strategy.
     *
     * @param {Array<string>} entrypoints The list of entrypoints that will be
     *     analyzed for dependencies. The results of the analysis will be passed
     *     to the `strategy`. An array of length 1 will bypass the strategy and
     *     directly bundle the document.
     * @param {BundleStrategy} strategy The strategy used to construct the
     *     output bundles. See 'polymer-analyzer/lib/bundle-manifest' for
     *     examples. UNUSED.
     */
    bundle(entrypoints: string[], strategy?: BundleStrategy, mapper?: BundleUrlMapper): Promise<DocumentCollection>;
    /**
     * Append a <link rel="import" node to `node` with a value of `url` for
     * the "href" attribute.
     */
    private _appendImport(node, url);
    private _synthesizeBundleContents(bundle, reachedImports);
    private _bundleDocument(bundle, bundleManifest, bundleImports?);
}
